## 面试题

> 1.redis扩容，怎么实现redis扩容？

```json
redis优点:
	1.读写性能优异，从内存中进行IO读写速度快。
	2.支持数据持久化，支持AOF和RDB两种持久方式。
		RDB持久化:指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集		写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储
		AOF持久化：以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。
	3.支持主从复制。
	4.数据结构丰富。
	5.redis是单线程cpu，这样速度更快。因为单线程没有切换的开销。不需要考虑加减锁操作。多路复用IO模型，效率高

redis缺点：
	1.主从同步，如果主机挂掉，宕机前有一部分数据没有同步到从机，会导致数据不一致
	2.主从同步，数据同步会有延迟
	3.读写分离，主机写的负载量太大，也会导致主机的宕机

#redis扩容:
	1.集群，使用代理，达到集群的目的
	2.主从同步，读写分离 （根据需求控制读写分离比例）
```



> 2.区块链怎么实现分布式和去中心化问题？

```json
# 中心化:
	1.人手一个数据备份。你很重要，每个人都是主角（配角），主人翁精神
# 去中心化解决的问题：
	1.防篡改，更稳定可靠。
# 去中心化跟比特币有啥关系:
	1.比特币就是一个具有转账支付功能的功能的去中心化系统。

# 分布式：
	1.分布式存储是一种数据存储技术，通过网络使用每台机器上的磁盘空间，并将这些分散的存储资源构成一个虚拟的存储设备，数据分散的存储在网络中的各个角落。

```

> 3. go开发中如何解决bug?

```json
方式：
	1.写好打印方法，根据打印方法确定Bug位置。
	2.通过pprof来分析内存泄漏或剧增等问题。
	3.查看崩溃日志，猜测崩溃原因。
```

> 4.怎么实现并发?

```json
goroutine:
	轻量级线程，协成就是一个不由os内核抢占调度，而是由程序管理在用户态自管理的协作式“线程”。
优点：
	1.省去了cpu线程切换的开销。
	2.降低了内存的消耗
	3.提高了cpu缓存的命中率
	4.不提高硬件的前提下，提升了系统的负载能力。

# go语言使用MPG模式来实现CSP
	M指的是Machine，一个M直接关联了一个内核线程。
	P指的是”processor”，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。
	G指的是Goroutine，其实本质上也是一种轻量级的线程。

个人理解：
	M关联了一个内核线程，通过调度器P（上下文）的调度，可以连接1个或者多个G，相当于把一个内核线程切分成N个用户线程，M和P是一对一关系（但是实际调度中关系多变），通过P调度N个G（P和G是一对多关系），实现内核线程和G的多对多关系（M:N），通过这个方式，一个内核线程就可以起N个Goroutine，同样硬件配置的机器可用的用户线程就成几何级增长，并发性大幅提高。
```

> Tcp协议三次握手四次挥手

```json
网络分层架构：
	1.应用层		http、ftp、telnet、nfs、ssh #:源应用 —— 目标应用。
	2.传输层		tcp,udp #:源port —— 目标port
	3.网络层		IP、ICMP、IGMP #:源IP —— 目标IP
	4.链路层		ARP、RARP	#:源Mac —— 目标Mac

三次握手:
	1.客户端，主动发起连接请求。发 SYN 标志位，携带序号，字节数。
	2.服务器，接受SYN请求。发送ACK应答，携带确认序号，同时发 SYN标志位，携带序号，字节数。
	3.客户端，接受 ACK、SYN。发送 ACK应答，携带确认序号。

四次挥手：
	1.客户端，发送关闭连接请求。发送FIN标志位，携带 序号包。
	2.服务器，接受 FIN标志位，回发 ACK标志位，携带确认序号
				—— 客户端 收到 ACK标志位后，标志着 “半关闭”完成。
	3.服务器，发送关闭连接请求。发送FIN标志位，携带 序号包。
	4.客户端，接受 FIN标志位，回发 ACK标志位，携带确认序号。 
				—— 当客户端，将最后一个ACK发送，并成功被对端接收。标志着 4次挥手完成。

```

> 并发与并行

```json
并行：
	依赖计算机硬件，实现统一时刻有多个任务并行执行。
并发：
	依赖cpu的高速运算能力，在多个任务中，飞快切换，从而达到“同时”运行多个任务的目的。
```

> 实现一个掷色子过程？
>
> A 负责掷色子，每次掷一个色子
>
> B负责记录每次的色子
>
> 如果连续三次都是6，则退出

```go
var ch = make(chan int)
func main(){
  rand.Seed(time.Now().UnixNano()) 
  go goWrite()
  go goRead()
  for {
    ;
  }
}
//负责写
func goWrite(){
  c := rand.intn(6)
  ch<- c
}
//负责读
func goRead(){
  c:=<-ch
  fmt.println("read:",c)
}
```

> 递归遍历一个目录，统计目录及子目录各种类型文件的数目，统计完后，打印各种文件的扩展名及其数目？

```go
func GetAllFile(path string) err{
  r,err:=ioutil.ReadDir(path)
  for _,fi :=range r{
    if fi.IsDir{
      GetAllFile(path+fi.Name()+"\")
     }else{
        fmt.Println(fi.Name())         
     }
  }
  return err
}
```

> Struct{} 使用空结构体的好处，提供一些使用很好的struct{}例子

```go
空struct好处：
	1.节省内存
	2.struct{}可以向人展示对象中不需要任何数据，仅包含需要方法。在调用也并无任何区别

//例子:
dict:=make(map[string]struct{})
for _, value := range []string{"apple", "orange", "apple"} {
   dict[value] = struct{}{}
}
```

> 复制一个slice ,map ,interface

```go
//golang 深拷贝代码
func Clone(a, b interface{}) error {
    buff := new(bytes.Buffer)
    enc := gob.NewEncoder(buff)
    dec := gob.NewDecoder(buff)
    if err := enc.Encode(a); err != nil {
        return err
    }
    if err := dec.Decode(b); err != nil {
        return err
    }
    return nil
}
```

> 结构体比较，两个interface比较？

```go
//结构体比较
reflect.DeepEqual(结构体1, 结构体2)
//interface比较
reflect.DeepEqual(a, b interface{})
```

> 音乐网站，展示每天歌曲的歌名排行榜，听的人越多，排的越靠前？

```json
个人解决方案：
	1.我们假设数据库中的每首歌都有一个唯一的递增的ID字段。
	2.使用分页来制作歌曲主页列表跟总列表。
	3.使用reids对数字进行递增和递减操作实现非常好。集合set和有序集合sort set也使得我们执行变的简单。
	4.zrange music_rank 0-10 
```

> Pow 工作量证明（挖矿）

```json
实现流程:
	sha256(区块数据+随机数)<目标的哈希
```

> 地址生成流程

![image-20191106170646694](image-20191106170646694.png)

